' Copyright (c) 2022 Thomas Hugo Williams
' License MIT <https://opensource.org/licenses/MIT>
' For MMBasic 5.07.05

Option Base 0
Option Default None
Option Explicit On

' Option LcdPanel NoConsole

'!set CTRL_NO_SNES
#Include "ctrl.ipp"
#Include "sound.inc"
#Include "highscr.inc"
#Include "menu.inc"

Const VERSION$ = "0.9.0"

Select Case Mm.Device$
  Case "Colour Maximite 2", "Colour Maximite 2 G2", "MMBasic for Windows"
    Const HIGHSCORE_FILENAME$ = Mm.Info(Path) + "high-scores/lazer-cycle.csv"
    Const IS_CMM2% = 1
    Mode 7
    Page Write 1
  Case "PicoMite", "PicoMiteVGA"
    If Val(Mm.Info(CpuSpeed)) < 252000000 Then Error "Requires OPTION CPUSPEED 252000 or 378000"
    Const HIGHSCORE_FILENAME$ = "/high-scores/lazer-cycle.csv"
    Const IS_CMM2% = 0
    If Mm.Device$ = "PicoMiteVGA" Then Mode 2
  Case Else
    Error "Unsupported device: " + Mm.Device$
End Select

' Text deliberately padded to string width (40 chars).
If Mm.Device$ = "MMBasic for Windows" Then
  Const START_TEXT$ = "              Press SPACE               "
Else
  Const START_TEXT$ = "       Press START, FIRE or SPACE       "
EndIf

Const WIDTH% = Mm.HRes \ 2
Const HEIGHT% = (Mm.VRes - 20) \ 2
Const X_OFFSET% = MM.HRes \ 2
Const Y_OFFSET% = MM.VRes \ 2
Const NORTH% = 0, EAST% = 1, SOUTH% = 2, WEST% = 3
Const MAX_CYCLE_IDX% = 3
Const SCORE_Y% = 2 * HEIGHT% + 4
Const STATE_OK%    = &b000 ' 0; values 1-3 are "imminent death"
Const STATE_DYING% = &b100 ' 4
Const STATE_DEAD%  = &b101 ' 5

' These would be constants but MMBasic does not support constant arrays
Dim NEXT_DIR%(7)        = (EAST%, NORTH%, WEST%, SOUTH%, EAST%, NORTH%, WEST%, SOUTH%)
Dim SCORE_X%(3)         = (35, 105, 175, 245)
Dim DIRECTIONS%(3)      = (-WIDTH%, 1, WIDTH%, -1)
Dim COMPASS_TO_CTRL%(3) = (ctrl.UP, ctrl.RIGHT, ctrl.DOWN, ctrl.LEFT)

Dim ui_ctrl$ ' Controller id for controlling the UI.
Dim attract_mode% = 1
Dim score%
Dim difficulty% = 1
Dim frame_duration%
Dim next_frame%

' Each cell of the arena takes up 1 byte:
'   bit  0   - occupied by cycle
'   bits 1-2 - index of cycle
'   bits 3-4 - direction cycle was going in when entered cell
'   bits 5-6 - unused
'   bit  7   - arena wall (other bits will be 0)
Dim arena%(HEIGHT% * WIDTH% \ 8)

Dim cycle.current% ' Current cycle index, set before calling controller subroutines.
Dim cycle.score%(MAX_CYCLE_IDX%)
Dim cycle.nxt%(MAX_CYCLE_IDX%)
Dim cycle.pos%(MAX_CYCLE_IDX%)
Dim cycle.dir%(MAX_CYCLE_IDX%)
Dim cycle.colour%(MAX_CYCLE_IDX%) = (Rgb(Red), Rgb(Yellow), Rgb(Cyan), Rgb(Green))
Dim cycle.ctrl$(MAX_CYCLE_IDX%) Length 32
Dim cycle.ctrl_setting$(MAX_CYCLE_IDX%) Length 32
Dim cycle.state%(MAX_CYCLE_IDX%)

Dim num_alive%
Dim num_humans%

Option Break 4
On Key 3, on_exit

init_globals()
clear_display()
sound.init()
outer_loop()
End

Sub outer_loop()
  Local attract_mode% = 1, i%

  Do
    If attract_mode% Then wipe() : attract_mode% = Not show_title%(5000)
    If attract_mode% Then wipe() : attract_mode% = Not show_highscore%(5000)
    If Not attract_mode% Then
      wipe()
      If Not menu.show%(ui_ctrl$, cycle.ctrl_setting$(), cycle.colour%()) Then on_exit()
    EndIf

    wipe()
    init_game(attract_mode%)
    draw_arena()

    If game_loop%() Then
      ' Game loop interrupted after all human players dead.
      attract_mode% = 0
    ElseIf Not attract_mode% Then
      ' Game ended normally whilst not in attract mode.
      show_game_over()
      attract_mode% = Not show_highscore%(5000)
    EndIf

    close_controllers()
  Loop
End Sub

' Break handler to stop music & fx when Ctrl-C pressed.
Sub on_exit()
  Play Stop
  On Key 3, 0
  Option Break 3
  close_controllers()
  Cls
  End
End Sub

' Initialises global variables.
Sub init_globals()
  Local a%, i%, j%

  ' Initialise list of controllers.
  Select Case Mm.Device$
    Case "PicoMite"    : Restore controller_data_pm
    Case "PicoMiteVGA" : Restore controller_data_pmvga
    Case Else          : Restore controller_data_cmm2
  End Select
  Local num_ctrl%, num_poll%
  Read num_ctrl%, num_poll%
  Dim CTRL_NAMES$(num_ctrl% - 1)
  Dim CTRL_SUBS$(num_ctrl% - 1)
  Dim CTRLS_TO_POLL$(num_poll% - 1)
  j% = 0
  For i% = 0 To num_ctrl% - 1
    Read CTRL_NAMES$(i%), CTRL_SUBS$(i%), a%
    If a% Then
      CTRLS_TO_POLL$(j%) = CTRL_SUBS$(i%)
      Inc j%
    EndIf
  Next

  ' Initialise controller settings.
  For i% = 0 To MAX_CYCLE_IDX%
    cycle.ctrl_setting$(i%) = "ai_control"
  Next

  ' Initialise high-scores.
  Restore highscore_data
  Local defaults$(Bound(highscr.values$(), 1))
  For i% = 0 To Bound(defaults$(), 1)
    Read defaults$(i%)
  Next
  highscr.load(HIGHSCORE_FILENAME$, defaults$())
End Sub

' Displays the title screen for a specified duration or until the user presses
' START/FIRE/SPACE.
'
' @param duration%  duration in milliseconds; if 0 then indefinite.
' @return           1 if the user pressed button/key,
'                   0 if the duration expired.
Function show_title%(duration%)
  Text X_OFFSET%, Y_OFFSET% - 15, "LAZER CYCLE", "CM", 1, 2, Rgb(White)
  Text X_OFFSET%, Y_OFFSET% + 8, "(c) 2022 Thomas Hugo Williams", "CM", 7, 1, Rgb(Cyan)
  Text X_OFFSET%, Y_OFFSET% + 20, "www.sockpuppetstudios.com", "CM", 7, 1, Rgb(Cyan)
  Text X_OFFSET%, Y_OFFSET% + 40, START_TEXT$, "CM", 1, 1, Rgb(White)
  If IS_CMM2% Then Page Copy 1 To 0, B
  show_title% = wait%(duration%)
End Function

' Displays the highscore table for a specified duration or until the user presses
' START/FIRE/SPACE.
'
' @param duration%  duration in milliseconds; if 0 then indefinite.
' @return           1 if the user pressed button/key,
'                   0 if the duration expired.
Function show_highscore%(duration%)
  Local ctrl$ = highscr.show_table$(CTRLS_TO_POLL$(), 5000)
  If ctrl$ <> "" Then
    If ui_ctrl$ = "" Then ui_ctrl$ = ctrl$
    show_highscore% = 1
  EndIf
End Function

Sub clear_display()
   Box 0, 0, Mm.HRes, Mm.VRes, 1, Rgb(Black), Rgb(Black)
   If IS_CMM2% Then Page Copy 1 To 0, B
End Sub

' Waits a specified duration for the user to press START on a (S)NES gamepad
' connected to Port A, or FIRE on an ATARI joystick connected to Port A or
' SPACE on the keyboard.
'
' @param duration%  duration in milliseconds; if 0 then indefinite.
' @return           1 if the user pressed button/key,
'                   0 if the duration expired.
Function wait%(duration%)
  ctrl.init_keys()
  Local ctrl$ = ctrl.poll_multiple$(CTRLS_TO_POLL$(), ctrl.A Or ctrl.B Or ctrl.START, duration%)
  If ctrl$ <> "" Then
    If ui_ctrl$ = "" Then ui_ctrl$ = ctrl$
    wait% = 1
  EndIf
End Function

Sub init_game(attract_mode%)
  frame_duration% = 3 * (5 + (6 - difficulty%))
  num_alive% = 0 ' Incremented later.
  num_humans% = 0
  score% = 0

  ' Initialise the arena.
  Local p_arena% = Peek(VarAddr arena%())
  Memory Set p_arena%, 0, HEIGHT% * WIDTH%
  Memory Set p_arena%, 128, WIDTH%
  Memory Set p_arena% + (HEIGHT% - 1) * WIDTH%, 128, WIDTH%
  Local y%
  For y% = 1 To HEIGHT% - 2
    Poke Byte p_arena% + y% * WIDTH%, 128
    Poke Byte p_arena% + (y% + 1) * WIDTH% - 1, 128
  Next

  ' Initialise game ports and keyboard routines.
  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    cycle.ctrl$(i%) = Choice(attract_mode%, "ai_control", cycle.ctrl_setting$(i%))
    On Error Ignore
    Call cycle.ctrl$(i%), ctrl.OPEN
    If Mm.ErrNo <> 0 Then cycle.ctrl$(i%) = "no_control"
    On Error Abort
  Next
  ctrl.init_keys()

  ' Initialise cycle state.
  cycle.dir%(0) = EAST%
  cycle.dir%(1) = WEST%
  cycle.dir%(2) = SOUTH%
  cycle.dir%(3) = NORTH%

  cycle.pos%(0) = WIDTH * (HEIGHT% \ 2) + 5
  cycle.pos%(1) = WIDTH% * (HEIGHT% \ 2) + WIDTH% - 6
  cycle.pos%(2) = 5.5 * WIDTH%
  cycle.pos%(3) = WIDTH% * (HEIGHT% - 6) + WIDTH% \ 2

  For i% = 0 To MAX_CYCLE_IDX%
    cycle.score%(i%) = 0
    If cycle.ctrl$(i%) = "no_control" Then
      cycle.pos%(i%) = -1
      cycle.nxt%(i%) = -1
      cycle.state%(i%) = STATE_DEAD%
    Else
      Inc num_alive%
      Inc num_humans%, cycle.ctrl$(i%) <> "ai_control"
      cycle.nxt%(i%) = cycle.pos%(i%) + DIRECTIONS%(cycle.dir%(i%))
      Poke Byte p_arena% + cycle.pos%(i%), (cycle.dir%(i%) << 3) + (i% << 1) + 1
      Poke Byte p_arena% + cycle.nxt%(i%), (cycle.dir%(i%) << 3) + (i% << 1) + 1
      cycle.state%(i%) = STATE_OK%
    EndIf
  Next
End Sub

Sub draw_arena()
  Local a%, i%, j%
  For i% = 0 To Bound(arena%(), 1) - 1
    a% = arena%(i%)
    If a% = 0 Then Continue For
    For j% = 0 To 7
      If Peek(Var a%, j%) <> 128 Then Continue For
      Pixel 2 * (((i% * 8) Mod WIDTH%) + j%), 2 * ((i% * 8) \ WIDTH%), Rgb(Grey)
    Next
  Next
End Sub

' @return  0 - normal game over
'          1 - game interrupted after all human players died
Function game_loop%()
  Local d%, i%, key%, next_frame% = Timer + frame_duration%

  ' num_alive% = 0
  ' cycle.score%(0) = 3175
  ' cycle.score%(1) = 2175
  ' cycle.score%(2) = 1175
  ' cycle.score%(3) = 975
  ' score% = 3175

  Do While num_alive% > 0
    Inc score%, 1
    If score% Mod 5 = 0 Then draw_score()

    ' When dying the cycle trail deletes at twice the rate.
    For i% = 0 To MAX_CYCLE_IDX%
      If cycle.state%(i%) = STATE_DYING% Then cycle.dying(i%)
    Next

    ' Draw cycles.
    For i% = 0 To MAX_CYCLE_IDX%
      If Not (cycle.state%(i%) And &b11) Then cycle.draw(i%)
    Next

    If IS_CMM2% Then Page Copy 1 To 0, I

    ' Move cycles.
    For i% = 0 To MAX_CYCLE_IDX%
      If Not (cycle.state%(i%) And &b11) Then cycle.pos%(i%) = cycle.nxt%(i%)
    Next

    ' Determine changes of direction and check for collisions.
    For i% = 0 To MAX_CYCLE_IDX%
      cycle.current% = i%
      Call cycle.ctrl$(i%), key%
      d% = cycle.dir%(i%)
      Select Case key%
        Case ctrl.UP:    If d% <> SOUTH% Then d% = NORTH%
        Case ctrl.DOWN:  If d% <> NORTH% Then d% = SOUTH%
        Case ctrl.LEFT:  If d% <> EAST% Then d% = WEST%
        Case ctrl.RIGHT: If d% <> WEST% Then d% = EAST%
      End Select
      cycle.dir%(i%) = d%
      cycle.nxt%(i%) = cycle.pos%(i%) + DIRECTIONS%(d%)
      If cycle.state%(i%) <> STATE_DEAD% Then cycle.check_collision(i%)
    Next

    ' Wait for next frame.
    Do While Timer < next_frame% : Loop
    Inc next_frame%, frame_duration%

    If num_humans% > 0 Then Continue Do

    ' Check for "attract mode" being interrupted.
    If ctrl.poll_single%(CTRLS_TO_POLL$(score% Mod (Bound(CTRLS_TO_POLL$(), 1) + 1)), ctrl.A Or ctrl.B Or ctrl.START) Then
      If ui_ctrl$ = "" Then ui_ctrl$ = CTRLS_TO_POLL$(score% Mod (Bound(CTRLS_TO_POLL$(), 1) + 1))
      num_alive% = 0
      game_loop% = 1
    EndIf
  Loop

  ' Ensure display updated at end of loop.
  If IS_CMM2% Then Page Copy 1 To 0, B

  ' Wait for current sound effect (if any) to complete.
  sound.wait_for_fx()
End Function

Sub draw_score()
  If num_humans% > 0 Or ((score% \ 100) And &b1) Then
    Local i%, s$ = Str$(score%, 5, 0, "0")
    For i% = 0 To MAX_CYCLE_IDX%
      If cycle.state%(i%) < STATE_DYING% Then
        Text SCORE_X%(i%), SCORE_Y%, s$, , 1, 1, cycle.colour%(i%)
      EndIf
    Next
    Exit Sub
  EndIf

  ' If there are no human players we toggle between the score and the "Press ..." text.
  If score% Mod 100 = 95 Then
    Local i%, sc%
    Text WIDTH%, SCORE_Y%, Space$(40), "C", 1, 1, Rgb(White)
    For i% = 0 To MAX_CYCLE_IDX%
      sc% = Choice(cycle.state%(i%) < STATE_DYING%, score%, (cycle.score%(i%) \ 5) * 5)
      Text SCORE_X%(i%), SCORE_Y%, Str$(sc%, 5, 0, "0"), , 1, 1, cycle.colour%(i%)
    Next
  Else
    Text WIDTH%, SCORE_Y%, START_TEXT$, "C", 1, 1, Rgb(White)
  EndIf
End Sub

Sub wipe()
  Local y%
  sound.start_fx(sound.FX_WIPE%(), 1)
  For y% = 0 To Mm.VRes \ 2 Step 5
     Box WIDTH% - y% * 1.2, Mm.VRes \ 2 - y%, 2.4 * y%, 2 * y%, 5, Rgb(Cyan), Rgb(Black)
     If IS_CMM2% Then Page Copy 1 To 0, B
     Pause 30
  Next
  clear_display()
End Sub

' Draw cycle if STATE_OK% or STATE_DYING%.
Sub cycle.draw(idx%)
  Local p% = cycle.pos%(idx%), n% = cycle.nxt%(idx%)
  Line 2*(p% Mod WIDTH%), 2*(p%\WIDTH%), 2*(n% Mod WIDTH%), 2*(n%\WIDTH%), 1, cycle.colour%(idx%) * (cycle.state%(idx%) <> STATE_DYING%)
End Sub

Sub cycle.dying(idx%)
  cycle.draw(idx%)
  cycle.pos%(idx%) = cycle.nxt%(idx%) ' Move
  cycle.current% = idx%
  Local key%
  die_control(key%)
  Select Case key%
    Case ctrl.UP:    cycle.dir%(idx%) = NORTH%
    Case ctrl.DOWN:  cycle.dir%(idx%) = SOUTH%
    Case ctrl.LEFT:  cycle.dir%(idx%) = WEST%
    Case ctrl.RIGHT: cycle.dir%(idx%) = EAST%
  End Select
  cycle.nxt%(idx%) = cycle.pos%(idx%) + DIRECTIONS%(cycle.dir%(idx%))
  cycle.check_collision(idx%)
End Sub

Sub show_game_over()
  ' Sort scores and then round down to nearest 5.
  Local dummy%, i%, idx%(MAX_CYCLE_IDX%), j%, k%, winner%
  Sort cycle.score%(), idx%(), 1
  For i% = 0 To MAX_CYCLE_IDX%
    cycle.score%(i%) = (cycle.score%(i%) \ 5) * 5 ' Round down to nearest 5.
  Next
  winner% = idx%(0)

  Local txt$ = "PLAYER " + Str$(winner% + 1) + " WINS"
  Text X_OFFSET%, Y_OFFSET% - 25, txt$, "CM", 1, 2, cycle.colour%(winner%)
  Text X_OFFSET%, Y_OFFSET% + 5, "SCORE: " + Str$(cycle.score%(0)), "CM", 1, 2, cycle.colour%(winner%)
  If IS_CMM2% Then Page Copy 1 To 0, B
  dummy% = wait%(5000)

  wipe()

  ' Insert into high-score table.
  ' For the moment only the winner can enter a high-score,
  ' to change that make the upper bound of the FOR statement = MAX_CYCLE_IDX%
  Local new_highscore%, player%
  For i% = 0 To 0
    player% = idx%(i%)
    If cycle.ctrl_setting$(player%) = "ai_control" Then Continue For
    For j% = 0 To Bound(highscr.values$())
      If cycle.score%(i%) > Val(Field$(highscr.values$(j%), 2)) Then
        For k% = Bound(highscr.values$(), 1) To j% Step -1
          If k% <> 0 Then highscr.values$(k%) = highscr.values$(k% - 1)
        Next
        highscr.values$(j%) = ", " + Str$(cycle.score%(i%))
        highscr.edit(player% + 1, j%, cycle.colour%(player%), cycle.ctrl_setting$(player%))
        new_highscore% = 1
        Exit For
      EndIf
    Next
  Next
  If new_highscore% Then highscr.save(HIGHSCORE_FILENAME$)
End Sub

Sub ai_control(x%)
  If x% < 0 Then Exit Sub

  Local idx% = cycle.current%
  Local d% = cycle.dir%(idx%)

  ' Random element.
  Local i% = Int(500 * Rnd)
  If i% < 4 Then d% = NEXT_DIR%(i% + idx%)

  ' Avoid collisions.
  Local nxt%
  For i% = 0 To MAX_CYCLE_IDX%
    nxt% = cycle.pos%(idx%) + DIRECTIONS%(d%)
    If Not Peek(Var arena%(), nxt%)) Then Exit For
    d% = NEXT_DIR%(i% + idx%)
  Next

  x% = COMPASS_TO_CTRL%(d%)
End Sub

Sub die_control(x%)
  If x% < 0 Then Exit Sub
  Local bits% = Peek(Var arena%(), cycle.pos%(cycle.current%)) >> 1
  If (bits% And &b11) = cycle.current% Then
    bits% = (bits% >> 2) And &b11
    x% = COMPASS_TO_CTRL%((bits% + 2) Mod 4)
  EndIf
End Sub

Sub no_control(x%)
  x% = 0
End Sub

Sub keys_cegg(x%)
  If x% < 0 Then Exit Sub
  x% =    ctrl.keydown%(32)  * ctrl.A     ' Space
  Inc x%, ctrl.keydown%(97)  * ctrl.UP    ' A
  Inc x%, ctrl.keydown%(122) * ctrl.DOWN  ' Z
  Inc x%, ctrl.keydown%(44)  * ctrl.LEFT  ' comma
  Inc x%, ctrl.keydown%(46)  * ctrl.RIGHT ' full-stop
End Sub

Sub keys_azxc(x%)
  If x% < 0 Then Exit Sub
  x% =    ctrl.keydown%(32)  * ctrl.A     ' Space
  Inc x%, ctrl.keydown%(97)  * ctrl.UP    ' A
  Inc x%, ctrl.keydown%(122) * ctrl.DOWN  ' Z
  Inc x%, ctrl.keydown%(120) * ctrl.LEFT  ' X
  Inc x%, ctrl.keydown%(99)  * ctrl.RIGHT ' C
End Sub

Sub keys_ikop(x%)
  If x% < 0 Then Exit Sub
  x% =    ctrl.keydown%(32)  * ctrl.A     ' Space
  Inc x%, ctrl.keydown%(105) * ctrl.UP    ' I
  Inc x%, ctrl.keydown%(107) * ctrl.DOWN  ' K
  Inc x%, ctrl.keydown%(111) * ctrl.LEFT  ' O
  Inc x%, ctrl.keydown%(112) * ctrl.RIGHT ' P
End Sub

Sub cycle.check_collision(idx%)
  ' Handle dying.
  If cycle.state%(idx%) = STATE_DYING% Then
    Poke Var arena%(), cycle.pos%(idx%), 0
    Local mask% = (idx% << 1) + 1
    If (Peek(Var arena%(), cycle.nxt%(idx%)) And mask%) <> mask% Then
      cycle.ctrl$(idx%) = "no_control"
      cycle.state%(idx%) = STATE_DEAD%
      cycle.pos%(idx%) = -1
    EndIf
    Exit Sub
  EndIf

  ' No collision occurred.
  If Not Peek(Var arena%(), cycle.nxt%(idx%)) Then
    Poke Var arena%(), cycle.nxt%(idx%), (cycle.dir%(idx%) << 3) + (idx% << 1) + 1
    cycle.state%(idx%) = STATE_OK%
    Exit Sub
  EndIf

  ' Collision occured - the player has a couple of frames to change direction.
  Inc cycle.state%(idx%)
  If cycle.state%(idx%) < STATE_DYING% Then Exit Sub

  ' Time to die.
  Inc num_alive%, -1
  If cycle.ctrl$(idx%) <> "ai_control" Then Inc num_humans%, -1
  cycle.ctrl$(idx%) = "die_control"
  cycle.nxt%(idx%) = cycle.pos%(idx%)
  cycle.score%(idx%) = score%
  sound.start_fx(sound.FX_DIE%(), 0)
End Sub

Sub close_controllers()
  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    close_controller_no_error(cycle.ctrl_setting$(i%))
  Next
End Sub

Sub close_controller_no_error(ctrl$)
  On Error Ignore
  Call ctrl$, ctrl.CLOSE
  On Error Abort
End Sub

controller_data_cmm2:

Data 10, 6
Data "KEYS: AZ,.",     "keys_cegg",  1
Data "KEYS: AZXC",     "keys_azxc",  0
Data "KEYS: IKOP",     "keys_ikop",  0
Data "JOYSTICK DX",    "atari_dx",   1
Data "NES GAMEPAD DX", "nes_dx",     1
Data "WII CTRL I2C1",  "wii_any_1",  1
Data "WII CTRL I2C2",  "wii_any_2",  1
Data "WII CTRL I2C3",  "wii_any_3",  1
Data "AI",             "ai_control", 0
Data "NONE",           "no_control", 0

controller_data_pm:

Data 6, 2
Data "KEYS: AZ,.", "keys_cegg",  1
Data "KEYS: AZXC", "keys_azxc",  0
Data "KEYS: IKOP", "keys_ikop",  0
Data "GAMEPAD",    "nes_a",      1
Data "AI",         "ai_control", 0
Data "NONE",       "no_control", 0

controller_data_pmvga:

Data 9, 5
Data "KEYS: AZ,.", "keys_cegg",  1
Data "KEYS: AZXC", "keys_azxc",  0
Data "KEYS: IKOP", "keys_ikop",  0
Data "GAMEPAD A",  "nes_a",      1
Data "GAMEPAD B",  "nes_b",      1
Data "JOYSTICK A", "atari_a",    1
Data "JOYSTICK B", "atari_b",    1
Data "AI",         "ai_control", 0
Data "NONE",       "no_control", 0

highscore_data:

Data "TOM, 2000"
Data "MICKEY, 1500"
Data "MIKE, 1250"
Data "PETER, 1000"
Data "DAVEY, 800"
Data "JOHN, 600"
Data "PAUL, 400"
Data "GEORGE, 200"
Data "RINGO, 100"
Data "MOOSE, 50"
