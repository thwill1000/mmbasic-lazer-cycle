' Copyright (c) 2022 Thomas Hugo Williams
' License MIT <https://opensource.org/licenses/MIT>
' For MMBasic 5.07.05

Option Base 0
Option Default None
Option Explicit On

' Option LcdPanel NoConsole

#Include "ctrl.ipp"
#Include "highscr.inc"

Const VERSION$ = "0.9.0"

Select Case Mm.Device$
  Case "Colour Maximite 2", "Colour Maximite 2 G2", "MMBasic for Windows"
    Const HIGHSCORE_FILENAME$ = Mm.Info(Path) + "high-scores/lazer-cycle.csv"
    Const IS_CMM2% = 1
    Dim POLL_THESE$(2) = ("keys_cursor", "atari_dx", "wii_classic_3")
    Mode 7
    Page Write 1
  Case "PicoMiteVGA"
    If Val(Mm.Info(CpuSpeed)) < 252000000 Then Error "Requires OPTION CPUSPEED 252000 or 378000"
    Const HIGHSCORE_FILENAME$ = "/high-scores/lazer-cycle.csv"
    Const IS_CMM2% = 0
    Dim POLL_THESE$(2) = ("keys_cursor", "nes_a", "atari_a")
    Mode 2
  Case Else
    Error "Unsupported device: " + Mm.Device$
End Select

Const WIDTH% = Mm.HRes \ 2
Const HEIGHT% = (Mm.VRes - 20) \ 2
Const X_OFFSET% = MM.HRes \ 2
Const Y_OFFSET% = MM.VRes \ 2
Const NORTH% = 0, EAST% = 1, SOUTH% = 2, WEST% = 3
Const MAX_CYCLE_IDX% = 3
Const SCORE_Y% = 2 * HEIGHT% + 4
Const STATE_OK%    = &b000 ' 0; values 1-3 are "imminent death"
Const STATE_DYING% = &b100 ' 4
Const STATE_DEAD%  = &b101 ' 5

' These would be constants but MMBasic does not support constant arrays
Dim FREQUENCY!(127)
Dim NO_MUSIC%(1)        = (&h0000000000000000, &hFFFFFFFF00000000)
Dim SOUNDFX_NOTHING%(1) = (&hFFFFFFFFFFFFFFFF, &hFFFFFFFFFFFFFFFF)
Dim SOUNDFX_SELECT%(1)  = (&hFFFFFFFF0048443C, &hFFFFFFFFFFFFFFFF)
Dim SOUNDFX_DIE%(3)     = (&h4748494A4B4C4D4E, &h3F40414243444546, &h0038393A3B3C3D3E, &hFFFFFFFFFFFFFFFF)
Dim SOUNDFX_WIPE%(3)    = (&h3F3E3D3C3B3A3938, &h4746454443424140, &h004E4D4C4B4A4948, &hFFFFFFFFFFFFFFFF)
Dim NEXT_DIR%(7)        = (EAST%, NORTH%, WEST%, SOUTH%, EAST%, NORTH%, WEST%, SOUTH%)
Dim SCORE_X%(3)         = (35, 105, 175, 245)
Dim DIRECTIONS%(3)      = (-WIDTH%, 1, WIDTH%, -1)
Dim COMPASS_TO_CTRL%(3) = (ctrl.UP, ctrl.RIGHT, ctrl.DOWN, ctrl.LEFT)

Dim ui_ctrl$ = "keys_cursor" ' Controller id for controlling the UI.
Dim attract_mode% = 1
Dim score%
Dim difficulty% = 1
Dim frame_duration%
Dim next_frame%

' Each cell of the arena takes up 1 byte:
'   bit  0    - occupied by cycle
'   bits 1-2 - index of cycle
'   bits 3-4 - direction cycle was going in when entered cycle
'   bits 5-6 - unused
'   bit  7   - arena wall (other bits will be 0)
Dim arena%(HEIGHT% * WIDTH% \ 8)

Dim cycle.current% ' Current cycle index, set before calling ctrl_xxx() functions.
Dim cycle.is_ai%(MAX_CYCLE_IDX%)
Dim cycle.score%(MAX_CYCLE_IDX%)
Dim cycle.nxt%(MAX_CYCLE_IDX%)
Dim cycle.pos%(MAX_CYCLE_IDX%)
Dim cycle.dir%(MAX_CYCLE_IDX%)
Dim cycle.colour%(MAX_CYCLE_IDX%) = (Rgb(Red), Rgb(Yellow), Rgb(Cyan), Rgb(Green))
Dim cycle.ctrl$(MAX_CYCLE_IDX%) Length 32
Dim cycle.ctrl_backup$(MAX_CYCLE_IDX%) Length 32
Dim cycle.state%(MAX_CYCLE_IDX%)

Dim music_start_ptr% = Peek(VarAddr NO_MUSIC%())
Dim music_ptr% = music_start_ptr%
Dim soundfx_flag% = 1
Dim soundfx_ptr% = Peek(VarAddr SOUNDFX_NOTHING%())
Dim num_players%
Dim num_humans%

Option Break 4
On Key 3, on_quit

init_globals()
read_music()
clear_display()

music_start_ptr% = Peek(VarAddr MUSIC%())

' Music and sound effects are played on SetTick interrupts.
SetTick 200, play_music, 1
SetTick 40, play_soundfx, 2

Do
  If attract_mode% Then
    wipe()
    attract_mode% = Not show_title%(5000)
  EndIf

  If attract_mode% Then
    wipe()
    attract_mode% = Not show_highscore%(5000)
  EndIf

  wipe()

  If attract_mode% Then
    init_attract_mode()
  Else
    show_menu()
    wipe()
  EndIf

  init_game()
  draw_arena()

  Select Case game_loop%()
    Case 0
      show_game_over()
      attract_mode% = Not show_highscore%(5000)
    Case 1
      attract_mode% = 1
    Case 2
      attract_mode% = 0
    Case Else
      Error "Invalid value for 'attract_mode%'"
  End Select

  close_controllers()
Loop

End

' Break handler to stop music & fx when Ctrl-C pressed.
Sub on_quit()
  Play Stop
  On Key 3, 0
  Option Break 3
  close_controllers()
  End
End Sub

' Initialises global variables.
Sub init_globals()
  Local i%
  ' FREQUENCY(0) - rest - 10 Hz, which should be inaudible.
  ' FREQUENCY(1) - C0   - 16.35 Hz
  FREQUENCY!(0) = 10.0
  For i% = 1 To 127
    FREQUENCY!(i%) = 440 * 2^((i% - 58) / 12.0)
  Next

  ' Initialise list of controllers.
  If InStr(Mm.Device$, "PicoMite") Then
    Restore controller_data_pm
  Else
    Restore controller_data_cmm2
  EndIf
  Local num_ctrl%
  Read num_ctrl%
  Dim CTRL_NAMES$(num_ctrl% - 1)
  Dim CTRL_SUBS$(num_ctrl% - 1)
  For i% = 0 To num_ctrl% - 1
    Read CTRL_NAMES$(i%), CTRL_SUBS$(i%)
  Next

  ' Initialise high-scores.
  Restore highscore_data
  Local defaults$(Bound(highscr.values$(), 1))
  For i% = 0 To Bound(defaults$(), 1)
    Read defaults$(i%)
  Next
  highscr.load(HIGHSCORE_FILENAME$, defaults$())
End Sub

Sub read_music()
  Restore music_data
  Local count%
  Read count%
  Local num_channels%
  Read num_channels%
  count% = count% \ 8
  Dim MUSIC%(count%)
  Local i%
  For i% = 1 To count%
    Read MUSIC%(i% - 1)
  Next
End Sub

' Displays the title screen for a specified duration or until the user presses
' START/FIRE/SPACE.
'
' @param duration%  duration in milliseconds; if 0 then indefinite.
' @return           1 if the user pressed button/key,
'                   0 if the duration expired.
Function show_title%(duration%)
  Text X_OFFSET%, Y_OFFSET% - 15, "LAZER CYCLE", "CM", 1, 2, Rgb(White)
  Text X_OFFSET%, Y_OFFSET% + 8, "(c) 2022 Thomas Hugo Williams", "CM", 7, 1, Rgb(Cyan)
  Text X_OFFSET%, Y_OFFSET% + 20, "www.sockpuppetstudios.com", "CM", 7, 1, Rgb(Cyan)
  Local text$ = Choice(Mm.Device$ <> "MMBasic for Windows", "Press START, FIRE or SPACE", "Press SPACE")
  Text X_OFFSET%, Y_OFFSET% + 40, text$, "CM", 1, 1, Rgb(White)
  If IS_CMM2% Then Page Copy 1 To 0, B
  show_title% = wait%(duration%)
End Function

' Displays the highscore table for a specified duration or until the user presses
' START/FIRE/SPACE.
'
' @param duration%  duration in milliseconds; if 0 then indefinite.
' @return           1 if the user pressed button/key,
'                   0 if the duration expired.
Function show_highscore%(duration%)
  Local ctrl$ = highscr.show_table$(5000)
  If ctrl$ <> "" Then
    ui_ctrl$ = ctrl$
    show_highscore% = 1
  EndIf
End Function

Sub clear_display()
   Box 0, 0, Mm.HRes, Mm.VRes, 1, Rgb(Black), Rgb(Black)
   If IS_CMM2% Then Page Copy 1 To 0, B
End Sub

' Waits a specified duration for the user to press START on a (S)NES gamepad
' connected to Port A, or FIRE on an ATARI joystick connected to Port A or
' SPACE on the keyboard.
'
' @param duration%  duration in milliseconds; if 0 then indefinite.
' @return           1 if the user pressed button/key,
'                   0 if the duration expired.
Function wait%(duration%)
  ctrl.init_keys()
  Local ctrl$ = ctrl.poll$(duration%, POLL_THESE$())
  If ctrl$ <> "" Then
    ui_ctrl$ = ctrl$
    wait% = 1
  EndIf
End Function

Function str.lpad$(s$, x%)
  str.lpad$ = s$
  If Len(s$) < x% Then str.lpad$ = Space$(x% - Len(s$)) + s$
End Function

Function str.rpad$(s$, x%)
  str.rpad$ = s$
  If Len(s$) < x% Then str.rpad$ = s$ + Space$(x% - Len(s$))
End Function

Sub show_menu()
  Const x% = X_OFFSET% - 100
  Local key%, i%, item% = 0, update% = 1
  Local sounds$(3) = ("MUSIC & FX", "MUSIC ONLY", "FX ONLY   ", "NONE      ")
  Local sound_setting% = Choice(music_start_ptr% = Peek(VarAddr MUSIC%()), 1, 3) - soundfx_flag%

  ' Initialise cycle.ctrl_backup$() on first entry to this subroutine,
  ' subsequent calls use the previously stored state.
  If cycle.ctrl_backup$(0) = "" Then
    cycle.ctrl_backup$(0) = ui_ctrl$
    If cycle.ctrl_backup$(0) = "keys_cursor" Then cycle.ctrl_backup$(0) = "keys_cegg"
    For i% = 1 To MAX_CYCLE_IDX% : cycle.ctrl_backup$(i%) = "ai_control" : Next
  EndIf

  For i% = 0 To MAX_CYCLE_IDX% : cycle.ctrl$(i%) = cycle.ctrl_backup$(i%) : Next

  ' Text X_OFFSET%, Y_OFFSET% + 75, "Music by Scott Joplin", "CM", 7, 1, Rgb(Cyan)
  Text X_OFFSET%, Y_OFFSET% + 90, "Game Version " + VERSION$, "CM", 7, 1, Rgb(Cyan)

  ctrl.init_keys()
  On Error Ignore
  Call ui_ctrl$, ctrl.OPEN
  On Error Abort

  Do

    If update% Then
      Text x%, Y_OFFSET% - 95, "START GAME", , 1, 1, Rgb(White)
      text_for_controller(x%, Y_OFFSET% - 75, 0)
      text_for_controller(x%, Y_OFFSET% - 55, 1)
      text_for_controller(x%, Y_OFFSET% - 35, 2)
      text_for_controller(x%, Y_OFFSET% - 15, 3)
      Text x%, Y_OFFSET% + 5,  "DIFFICULTY: " + Str$(difficulty%), , 1, 1, Rgb(White)
      Text x%, Y_OFFSET% + 25, "SOUND:      " + sounds$(sound_setting%), , 1, 1, Rgb(White)
      Text x%, Y_OFFSET% + 45, "QUIT", , 1, 1, Rgb(White)
      Text x% - 15, Y_OFFSET% - 95 + item% * 20, Chr$(137), , 1, 1, Rgb(Cyan)
      If IS_CMM2% Then Page Copy 1 To 0, B
      Pause 200
      update% = 0
    EndIf

    Call ui_ctrl$, key%
    If key% = 0 Then keys_cursor(key%) ' Always respond to the keyboard.
    Select Case key%
      Case ctrl.START
        Exit Do

      Case ctrl.UP
        If item% > 0 Then
          Text x% - 15, Y_OFFSET% - 95 + item% * 20, Chr$(137), , 1, 1, Rgb(Black)
          Inc item%, -1
          update% = 1
        EndIf

      Case ctrl.DOWN
        If item% < 7 Then
          Text x% - 15, Y_OFFSET% - 95 + item% * 20, Chr$(137), , 1, 1, Rgb(Black)
          Inc item%
          update% = 1
        EndIf

      Case ctrl.LEFT, ctrl.RIGHT, ctrl.A
        Select Case item%
          Case 0
            If key% = ctrl.A Then Exit Do

          Case 1,2,3,4
            update_controller(item% - 1, Choice(key% = ctrl.LEFT, -1, +1))
            update% = 1

          Case 5 ' Difficulty
            Inc difficulty%, Choice(key% = ctrl.LEFT, -1, 1)
            If difficulty% < 1 Then difficulty% = 5
            If difficulty% > 5 Then difficulty% = 1
            update% = 1

          Case 6 ' Sound
            Inc sound_setting%, Choice(key% = ctrl.LEFT, -1, 1)
            If sound_setting% < 0 Then sound_setting% = 3
            If sound_setting% > 3 Then sound_setting% = 0
            music_start_ptr% = Choice(sound_setting% And &b10, Peek(VarAddr NO_MUSIC%()), Peek(VarAddr MUSIC%()))
            music_ptr% = music_start_ptr%
            soundfx_flag% = Not (sound_setting% And &b01)
            update% = 1

          Case 7 ' Quit
            If key% = ctrl.A Then on_quit()

        End Select

    End Select

    If update% = 1 Then start_soundfx(Peek(VarAddr SOUNDFX_SELECT%()), 1)

  Loop

  For i% = 0 To MAX_CYCLE_IDX% : cycle.ctrl_backup$(i%) = cycle.ctrl$(i%) : Next

  close_controller_no_error(ui_ctrl$)
End Sub

Sub text_for_controller(x%, y%, idx%)
  Local txt$ = "PLAYER " + Str$(idx% + 1) + ":   " + get_controller_name$(idx%)
  Text x%, y%, txt$, , 1, 1, cycle.colour%(idx%)
End Sub

Function get_controller_name$(idx%)
  Local i%
  For i% = 0 To Bound(CTRL_SUBS$(), 1)
    If cycle.ctrl$(idx%) = CTRL_SUBS$(i%) Then
      get_controller_name$ = CTRL_NAMES$(i%)
      Do While Len(get_controller_name$) < 13 : Cat get_controller_name$, " " : Loop
      Exit Function
    Endif
  Next
  Error "Unknown controller: " + cycle.ctrl$(idx%)
End Function

Sub update_controller(idx%, delta%)
  ' Find index of currently selected controller.
  Local i%
  For i% = 0 To Bound(CTRL_SUBS$(), 1)
    If cycle.ctrl$(idx%) = CTRL_SUBS$(i%) Then Exit For
  Next
  If i% = Bound(CTRL_SUBS$(), 1) + 1 Then Error "Unknown controller: " + cycle.ctrl$(idx%)

  Local ok%
  Do
    Inc i%, delta%
    If i% < 0 Then i% = Bound(CTRL_SUBS$(), 1)
    If i% > Bound(CTRL_SUBS$(), 1) Then i% = 0

    ' Check there is no conflict with other player's controller choice.
    If has_controller%(idx%, CTRL_SUBS$(i%)) Then Continue Do
    Select Case CTRL_SUBS$(i%)
      Case "atari_a"   : ok% = Not has_controller%(idx%, "nes_a")
      Case "atari_b"   : ok% = Not has_controller%(idx%, "nes_b")
      Case "nes_a"     : ok% = Not has_controller%(idx%, "atari_a")
      Case "nes_b"     : ok% = Not has_controller%(idx%, "atari_b")
      Case "keys_cegg" : ok% = Not has_controller%(idx%, "keys_azxc")
      Case "keys_azxc" : ok% = Not has_controller%(idx%, "keys_cegg")
      Case Else        : ok% = 1
    End Select
  Loop Until ok%

  cycle.ctrl$(idx%) = CTRL_SUBS$(i%)
End Sub

' Is any player other than idx% using the specified controller ?
Function has_controller%(idx%, ctrl$)
  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    If i% = idx% Then Continue For
    If cycle.ctrl$(i%) = ctrl$ Then has_controller% = 1
  Next
End Function

Sub init_attract_mode()
  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    cycle.ctrl$(i%) = "ai_control"
  Next
  attract_mode% = 1
End Sub

Sub init_game()
  frame_duration% = 3 * (5 + (6 - difficulty%))
  num_players% = 0 ' Incremented later.
  num_humans% = 0
  score% = 0

  ' Initialise the arena.
  Local p_arena% = Peek(VarAddr arena%())
  Memory Set p_arena%, 0, HEIGHT% * WIDTH%
  Memory Set p_arena%, 128, WIDTH%
  Memory Set p_arena% + (HEIGHT% - 1) * WIDTH%, 128, WIDTH%
  Local y%
  For y% = 1 To HEIGHT% - 2
    Poke Byte p_arena% + y% * WIDTH%, 128
    Poke Byte p_arena% + (y% + 1) * WIDTH% - 1, 128
  Next

  cycle.dir%(0) = EAST%
  cycle.dir%(1) = WEST%
  cycle.dir%(2) = SOUTH%
  cycle.dir%(3) = NORTH%

  cycle.pos%(0) = WIDTH * (HEIGHT% \ 2) + 5
  cycle.pos%(1) = WIDTH% * (HEIGHT% \ 2) + WIDTH% - 6
  cycle.pos%(2) = 5.5 * WIDTH%
  cycle.pos%(3) = WIDTH% * (HEIGHT% - 6) + WIDTH% \ 2

  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    cycle.is_ai%(i%) = cycle.ctrl$(i%) = "ai_control"
    cycle.score%(i%) = 0
    If cycle.ctrl$(i%) = "noop_control" Then
      cycle.pos%(i%) = -1
      cycle.nxt%(i%) = -1
      cycle.state%(i%) = STATE_DEAD%
    Else
      Inc num_players%
      If cycle.ctrl$(i%) <> "ai_control" Then Inc num_humans%
      cycle.nxt%(i%) = cycle.pos%(i%) + DIRECTIONS%(cycle.dir%(i%))
      Poke Byte p_arena% + cycle.pos%(i%), (cycle.dir%(i%) << 3) + (i% << 1) + 1
      Poke Byte p_arena% + cycle.nxt%(i%), (cycle.dir%(i%) << 3) + (i% << 1) + 1
      cycle.state%(i%) = STATE_OK%
    EndIf
  Next

  ' Initialise game ports and keyboard routines.
  For i% = 0 To MAX_CYCLE_IDX%
    On Error Ignore
    Call cycle.ctrl$(i%), ctrl.OPEN
    If Mm.ErrNo <> 0 Then cycle.ctrl$(i%) = "noop_control"
    On Error Abort
  Next
  ctrl.init_keys()
End Sub

Sub draw_arena()
  Local a%, i%, j%
  For i% = 0 To Bound(arena%(), 1) - 1
    a% = arena%(i%)
    If a% = 0 Then Continue For
    For j% = 0 To 7
      If Peek(Var a%, j%) <> 128 Then Continue For
      Pixel 2 * (((i% * 8) Mod WIDTH%) + j%), 2 * ((i% * 8) \ WIDTH%), Rgb(Grey)
    Next
  Next
End Sub

' @return  0 - normal game over
'          1 - attract mode game over
'          2 - attract mode interrupted
Function game_loop%()
  Local key%, ctrl$, i%
  game_loop% = attract_mode%
  next_frame% = Timer + frame_duration%

  ' num_players% = 0
  ' cycle.score%(0) = 3175
  ' cycle.score%(1) = 2175
  ' cycle.score%(2) = 1175
  ' cycle.score%(3) = 975
  ' score% = 3175

  Do While num_players% > 0
    Inc score%, 1
    If score% Mod 5 = 0 Then draw_score()

    ' When dying the cycle trail deletes at twice the rate.
    For i% = 0 To MAX_CYCLE_IDX%
      If cycle.state%(i%) = STATE_DYING% Then cycle.dying(i%)
    Next

    ' Draw cycles.
    For i% = 0 To MAX_CYCLE_IDX%
      If Not (cycle.state%(i%) And &b11) Then cycle.draw(i%)
    Next

    If IS_CMM2% Then Page Copy 1 To 0, I

    ' Move cycles.
    For i% = 0 To MAX_CYCLE_IDX%
      If Not (cycle.state%(i%) And &b11) Then cycle.pos%(i%) = cycle.nxt%(i%)
    Next

    ' Determine changes of direction and check for collisions.
    For i% = 0 To MAX_CYCLE_IDX%
      cycle.current% = i%
      Call cycle.ctrl$(i%), key%
      Select Case key%
        Case ctrl.UP:    cycle.dir%(i%) = NORTH%
        Case ctrl.DOWN:  cycle.dir%(i%) = SOUTH%
        Case ctrl.LEFT:  cycle.dir%(i%) = WEST%
        Case ctrl.RIGHT: cycle.dir%(i%) = EAST%
      End Select
      cycle.nxt%(i%) = cycle.pos%(i%) + DIRECTIONS%(cycle.dir%(i%))
      If cycle.state%(i%) <> STATE_DEAD% Then cycle.check_collision(i%)
    Next

    ' Wait for next frame.
    Do While Timer < next_frame% : Loop
    Inc next_frame%, frame_duration%

    If Not attract_mode% Then Continue Do

    ' Check for "attract mode" being interrupted.
    For i% = 0 To MAX_CYCLE_IDX%
      Call cycle.ctrl_backup$(i%), key%
      If key% = ctrl.A Or key% = ctrl.START Then
        num_players% = 0
        game_loop% = 2
      EndIf
    Next
  Loop

  ' Ensure display updated at end of loop.
  If IS_CMM2% Then Page Copy 1 To 0, B

  ' Wait for any sound effect to complete.
  Do While Peek(Byte soundfx_ptr%) <> &hFF : Loop
End Function

Sub draw_score()
  Local i%, s$ = Str$(score%, 5, 0, "0")
  For i% = 0 To MAX_CYCLE_IDX%
    If cycle.state%(i%) < STATE_DYING% Then
      Text SCORE_X%(i%), SCORE_Y%, s$, , 1, 1, cycle.colour%(i%)
    EndIf
  Next
End Sub

Sub wipe()
  Local y%
  start_soundfx(Peek(VarAddr SOUNDFX_WIPE%()), 1)
  For y% = 0 To Mm.VRes \ 2 Step 5
     Box WIDTH% - y% * 1.2, Mm.VRes \ 2 - y%, 2.4 * y%, 2 * y%, 5, Rgb(Cyan), Rgb(Black)
     If IS_CMM2% Then Page Copy 1 To 0, B
     Pause 30
  Next
  clear_display()
End Sub

' Draw cycle if STATE_OK% or STATE_DYING%.
Sub cycle.draw(idx%)
  Local p% = cycle.pos%(idx%), n% = cycle.nxt%(idx%)
  Line 2*(p% Mod WIDTH%), 2*(p%\WIDTH%), 2*(n% Mod WIDTH%), 2*(n%\WIDTH%), 1, cycle.colour%(idx%) * (cycle.state%(idx%) <> STATE_DYING%)
End Sub

Sub cycle.dying(idx%)
  cycle.draw(idx%)
  cycle.pos%(idx%) = cycle.nxt%(idx%) ' Move
  cycle.current% = idx%
  Local key%
  ctrl_die(key%)
  Select Case key%
    Case ctrl.UP:    cycle.dir%(idx%) = NORTH%
    Case ctrl.DOWN:  cycle.dir%(idx%) = SOUTH%
    Case ctrl.LEFT:  cycle.dir%(idx%) = WEST%
    Case ctrl.RIGHT: cycle.dir%(idx%) = EAST%
  End Select
  cycle.nxt%(idx%) = cycle.pos%(idx%) + DIRECTIONS%(cycle.dir%(idx%))
  cycle.check_collision(idx%)
End Sub

Sub show_game_over()
  ' Sort scores and then round down to nearest 5.
  Local dummy%, i%, idx%(MAX_CYCLE_IDX%), j%, k%, winner%
  Sort cycle.score%(), idx%(), 1
  For i% = 0 To MAX_CYCLE_IDX%
    Do While (cycle.score%(i%) Mod 5) <> 0 : Inc cycle.score%(i%), -1 : Loop
  Next
  winner% = idx%(0)

  Local txt$ = "PLAYER " + Str$(winner% + 1) + " WINS"
  Text X_OFFSET%, Y_OFFSET% - 25, txt$, "CM", 1, 2, cycle.colour%(winner%)
  Text X_OFFSET%, Y_OFFSET% + 5, "SCORE: " + Str$(cycle.score%(0)), "CM", 1, 2, cycle.colour%(winner%)
  If IS_CMM2% Then Page Copy 1 To 0, B
  dummy% = wait%(5000)

  wipe()

  ' Insert into high-score table.
  Local new_highscore%, player%
  For i% = 0 To MAX_CYCLE_IDX%
    player% = idx%(i%)
    If cycle.is_ai%(player%) Then Continue For
    For j% = 0 To Bound(highscr.values$())
      If cycle.score%(i%) > Val(Field$(highscr.values$(j%), 2)) Then
        For k% = Bound(highscr.values$(), 1) To j% Step -1
          If k% <> 0 Then highscr.values$(k%) = highscr.values$(k% - 1)
        Next
        highscr.values$(j%) = ", " + Str$(cycle.score%(i%))
        highscr.edit(player% + 1, j%, cycle.colour%(player%), cycle.ctrl_backup$(player%))
        new_highscore% = 1
        Exit For
      EndIf
    Next
  Next
  If new_highscore% Then highscr.save(HIGHSCORE_FILENAME$)
End Sub

Sub ai_control(x%)
  Local idx% = cycle.current%
  Local d% = cycle.dir%(idx%)

  ' Random element.
  Local i% = Int(500 * Rnd)
  If i% < 4 Then d% = NEXT_DIR%(i% + idx%)

  ' Avoid collisions.
  Local nxt%
  For i% = 0 To MAX_CYCLE_IDX%
    nxt% = cycle.pos%(idx%) + DIRECTIONS%(d%)
    If Not Peek(Var arena%(), nxt%)) Then Exit For
    d% = NEXT_DIR%(i% + idx%)
  Next

  x% = COMPASS_TO_CTRL%(d%)
End Sub

Sub ctrl_die(x%)
  x% = COMPASS_TO_CTRL%(((Peek(Var arena%(), cycle.pos%(cycle.current%)) >> 3) + 2) Mod 4)
End Sub

Sub keys_cegg(x%)
  x% =    ctrl.keydown%(97)  * ctrl.UP    ' A
  Inc x%, ctrl.keydown%(122) * ctrl.DOWN  ' Z
  Inc x%, ctrl.keydown%(44)  * ctrl.LEFT  ' comma
  Inc x%, ctrl.keydown%(46)  * ctrl.RIGHT ' full-stop
End Sub

Sub keys_azxc(x%)
  x% =    ctrl.keydown%(97)  * ctrl.UP    ' A
  Inc x%, ctrl.keydown%(122) * ctrl.DOWN  ' Z
  Inc x%, ctrl.keydown%(120) * ctrl.LEFT  ' X
  Inc x%, ctrl.keydown%(99)  * ctrl.RIGHT ' C
End Sub

Sub keys_ikop(x%)
  x% =    ctrl.keydown%(105) * ctrl.UP    ' I
  Inc x%, ctrl.keydown%(107) * ctrl.DOWN  ' K
  Inc x%, ctrl.keydown%(111) * ctrl.LEFT  ' O
  Inc x%, ctrl.keydown%(112) * ctrl.RIGHT ' P
End Function

Sub noop_control(x%)
  x% = 0
End Sub

Sub cycle.check_collision(idx%)
  ' Handle dying.
  If cycle.state%(idx%) = STATE_DYING% Then
    Poke Var arena%(), cycle.pos%(idx%), 0
    Local mask% = (idx% << 1) + 1
    If (Peek(Var arena%(), cycle.nxt%(idx%)) And mask%) <> mask% Then
      cycle.ctrl$(idx%) = "noop_control"
      cycle.state%(idx%) = STATE_DEAD%
      cycle.pos%(idx%) = -1
    EndIf
    Exit Sub
  EndIf

  ' No collision occurred.
  If Not Peek(Var arena%(), cycle.nxt%(idx%)) Then
    Poke Var arena%(), cycle.nxt%(idx%), (cycle.dir%(idx%) << 3) + (idx% << 1) + 1
    cycle.state%(idx%) = STATE_OK%
    Exit Sub
  EndIf

  ' Collision occured - the player has a couple of frames to change direction.
  Inc cycle.state%(idx%)
  If cycle.state%(idx%) < STATE_DYING% Then Exit Sub

  ' Time to die.
  Inc num_players%, -1
  If cycle.ctrl$(idx%) <> "ai_control" Then
    Inc num_humans%, -1
    If num_humans% = 0 Then attract_mode% = 1
  EndIf
  cycle.ctrl$(idx%) = "ctrl_die"
  cycle.nxt%(idx%) = cycle.pos%(idx%)
  cycle.score%(idx%) = score%
  start_soundfx(Peek(VarAddr SOUNDFX_DIE%()), 0)
End Sub

Sub close_controllers()
  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    close_controller_no_error(cycle.ctrl_backup$(i%))
  Next
End Sub

Sub close_controller_no_error(ctrl$)
  On Error Ignore
  Call ctrl$, ctrl.CLOSE
  On Error Abort
End Sub

' Called from interrupt to play next note of music.
Sub play_music()
  Local n% = Peek(Byte music_ptr%)
  If n% = 255 Then music_ptr% = music_start_ptr% : Exit Sub
  Play Sound 1, B, S, FREQUENCY!(n%), 15
  Play Sound 2, B, S, FREQUENCY!(Peek(Byte music_ptr% + 1)), 15
  Play Sound 3, B, S, FREQUENCY!(Peek(Byte music_ptr% + 2)), 15
  Inc music_ptr%, 3
End Sub

' Start a new sound effect.
Sub start_soundfx(ptr%, wait_%)
  If Not soundfx_flag% Then Exit Sub

  ' Wait for current sound effect to end.
  If wait_% Then Do While Peek(Byte soundfx_ptr%) <> &hFF : Loop

  soundfx_ptr% = ptr%

  ' Wait for first note of new sound effect to play.
  Do While soundfx_ptr% = ptr% : Loop
End Sub

' Called from interrupt to play next note of current sound effect.
Sub play_soundfx()
  Local n% = Peek(Byte soundfx_ptr%)
  If n% = 255 Then Exit Sub
  Play Sound 4, B, s, FREQUENCY!(n%), (n% <> 0) * 25
  Inc soundfx_ptr%
End Sub

' Gets bit i% of x%.
Function bits.get%(x%, i%)
  If i% < 0 Or i% > 63 Then Error "i% out of 0 .. 63 range"
  bits.get% = (x% And 1 << i%) <> 0
End Function

music_data:

Data 792   ' Number of bytes of music data.
Data 3     ' Number of channels.
Data &h3135000034000033, &h3500253D00313D00, &h00283D00283D0025, &h2A3D00293D002935
Data &h3D002C3D002A3D00, &h002E3D002E00002C, &h314100304000303F, &h4100293F00313D00
Data &h002A3C002A410029, &h253D002C3F002C3F, &h3D002C3D00253D00, &h00313D00313D002C
Data &h3135000034003133, &h3500253D00313D00, &h00283D00283D0025, &h2A3D00293D002935
Data &h3D002C3D002A3D00, &h002E3D002E3D002C, &h273700263800263A, &h41002B3D00273A00
Data &h002E3F002E41002B, &h2C3F00273A00273D, &h3F002A3F002C3F00, &h00293F00293F002A
Data &h2535002734002733, &h3500313D00253D00, &h00283D00283D0031, &h2A3D00293D002935
Data &h3D002C3D002A3D00, &h002E3D002E00002C, &h314100304000303F, &h4100293F00313D00
Data &h002A3C002A410029, &h313D002C3F002C3F, &h3D002C3D00313D00, &h00250000253D002C
Data &h3D4100253F00253D, &h41313D3F00003D31, &h00003D2F3B410000, &h3A4100003D2F3B3F
Data &h412E3A3F00003D2E, &h00003D2D39410000, &h384100003D2D393F, &h412C383F00003D2C
Data &h2C383C2C38410000, &h003D00003F00003F, &h3D202C3D00003D00, &h00003525313D202C
Data &h3538000037000036, &h3800363A31353831, &h2C00352C35380035, &h3538000037000036
Data &h3800363A31353831, &h2C00412C35380035, &h003A00003800003D, &h3F2A003D2A003C2A
Data &h2C003F2C00412A00, &h00382C003F2C003D, &h382C003825003825, &h3100353100382C00
Data &h3538000037000036, &h3800363A31353831, &h2C00352C35380035, &h3538000037000036
Data &h3800363A31353831, &h2C00382C35380035, &h003C32003B32003A, &h3C33000033003C33
Data &h27003A27003C3300, &h0038270033270037, &h382C00380000382C, &h2E00352E00380000
Data &h3538300037300036, &h3800363A31353831, &h2C00352C35380035, &h3538000037000036
Data &h3800363A31353831, &h2C00412C35380035, &h003A00003800003D, &h3F2A003D2A003C2A
Data &h2C003F2C00412A00, &h003D2C003F2C003D, &h3D2C003D25003D25, &h31003831003D2C00
Data &h363D000038000037, &h3D2A363A00003D2A, &h00003A2B373D0000, &h383800003A2B373D
Data &h442C384100003D2C, &h0000412935440000, &h363A00003829353D, &h3D2A363D00003A2A
Data &h00003F2C38410000, &h3D3D00003F2C383F, &h3D2C383D313D3D31, &h25313D25313D2C38
Data &hFFFF000000000000, &hFFFFFFFFFFFFFFFF, &hFFFFFFFFFFFFFFFF

controller_data_pm:

Data 9
Data "KEYS: AZ,.", "keys_cegg"
Data "KEYS: AZXC", "keys_azxc"
Data "KEYS: IKOP", "keys_ikop"
Data "GAMEPAD A",  "nes_a"
Data "GAMEPAD B",  "nes_b"
Data "JOYSTICK A", "atari_a"
Data "JOYSTICK B", "atari_b"
Data "AI",         "ai_control"
Data "NONE",       "noop_control"

controller_data_cmm2:

Data 9
Data "KEYS: AZ,.",    "keys_cegg"
Data "KEYS: AZXC",    "keys_azxc"
Data "KEYS: IKOP",    "keys_ikop"
Data "JOYSTICK DX",   "atari_dx"
Data "WII CLASSIC 1", "wii_classic_3" ' Port 1 => I2C3
Data "WII CLASSIC 2", "wii_classic_1" ' Port 2 => I2C1
Data "WII CLASSIC 3", "wii_classic_2" ' Port 3 => I2C2
Data "AI",            "ai_control"
Data "NONE",          "noop_control"

highscore_data:

Data "TOM, 2000"
Data "MICKEY, 1500"
Data "MIKE, 1250"
Data "PETER, 1000"
Data "DAVEY, 800"
Data "JOHN, 600"
Data "PAUL, 400"
Data "GEORGE, 200"
Data "RINGO, 100"
Data "MOOSE, 50"
