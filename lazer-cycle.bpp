' Copyright (c) 2022 Thomas Hugo Williams
' License MIT <https://opensource.org/licenses/MIT>
' For MMBasic 5.07.05

Option Base 0
Option Default None
Option Explicit On

' Option LcdPanel NoConsole

#Include "ctrl.ipp"
#Include "highscr.inc"
#Include "sound.inc"

Const VERSION$ = "0.9.0"

Select Case Mm.Device$
  Case "Colour Maximite 2", "Colour Maximite 2 G2", "MMBasic for Windows"
    Const HIGHSCORE_FILENAME$ = Mm.Info(Path) + "high-scores/lazer-cycle.csv"
    Const IS_CMM2% = 1
    Dim POLL_THESE$(2) = ("keys_cursor", "atari_dx", "wii_classic_3")
    Mode 7
    Page Write 1
  Case "PicoMiteVGA"
    If Val(Mm.Info(CpuSpeed)) < 252000000 Then Error "Requires OPTION CPUSPEED 252000 or 378000"
    Const HIGHSCORE_FILENAME$ = "/high-scores/lazer-cycle.csv"
    Const IS_CMM2% = 0
    Dim POLL_THESE$(2) = ("keys_cursor", "nes_a", "atari_a")
    Mode 2
  Case Else
    Error "Unsupported device: " + Mm.Device$
End Select

Const WIDTH% = Mm.HRes \ 2
Const HEIGHT% = (Mm.VRes - 20) \ 2
Const X_OFFSET% = MM.HRes \ 2
Const Y_OFFSET% = MM.VRes \ 2
Const NORTH% = 0, EAST% = 1, SOUTH% = 2, WEST% = 3
Const MAX_CYCLE_IDX% = 3
Const SCORE_Y% = 2 * HEIGHT% + 4
Const STATE_OK%    = &b000 ' 0; values 1-3 are "imminent death"
Const STATE_DYING% = &b100 ' 4
Const STATE_DEAD%  = &b101 ' 5

' These would be constants but MMBasic does not support constant arrays
Dim NEXT_DIR%(7)        = (EAST%, NORTH%, WEST%, SOUTH%, EAST%, NORTH%, WEST%, SOUTH%)
Dim SCORE_X%(3)         = (35, 105, 175, 245)
Dim DIRECTIONS%(3)      = (-WIDTH%, 1, WIDTH%, -1)
Dim COMPASS_TO_CTRL%(3) = (ctrl.UP, ctrl.RIGHT, ctrl.DOWN, ctrl.LEFT)

Dim ui_ctrl$ = "keys_cursor" ' Controller id for controlling the UI.
Dim attract_mode% = 1
Dim score%
Dim difficulty% = 1
Dim frame_duration%
Dim next_frame%

' Each cell of the arena takes up 1 byte:
'   bit  0    - occupied by cycle
'   bits 1-2 - index of cycle
'   bits 3-4 - direction cycle was going in when entered cycle
'   bits 5-6 - unused
'   bit  7   - arena wall (other bits will be 0)
Dim arena%(HEIGHT% * WIDTH% \ 8)

Dim cycle.current% ' Current cycle index, set before calling ctrl_xxx() functions.
Dim cycle.is_ai%(MAX_CYCLE_IDX%)
Dim cycle.score%(MAX_CYCLE_IDX%)
Dim cycle.nxt%(MAX_CYCLE_IDX%)
Dim cycle.pos%(MAX_CYCLE_IDX%)
Dim cycle.dir%(MAX_CYCLE_IDX%)
Dim cycle.colour%(MAX_CYCLE_IDX%) = (Rgb(Red), Rgb(Yellow), Rgb(Cyan), Rgb(Green))
Dim cycle.ctrl$(MAX_CYCLE_IDX%) Length 32
Dim cycle.ctrl_backup$(MAX_CYCLE_IDX%) Length 32
Dim cycle.state%(MAX_CYCLE_IDX%)

Dim num_players%
Dim num_humans%

Option Break 4
On Key 3, on_quit

init_globals()
clear_display()
sound.init()

Do
  If attract_mode% Then
    wipe()
    attract_mode% = Not show_title%(5000)
  EndIf

  If attract_mode% Then
    wipe()
    attract_mode% = Not show_highscore%(5000)
  EndIf

  wipe()

  If attract_mode% Then
    init_attract_mode()
  Else
    show_menu()
    wipe()
  EndIf

  init_game()
  draw_arena()

  Select Case game_loop%()
    Case 0
      show_game_over()
      attract_mode% = Not show_highscore%(5000)
    Case 1
      attract_mode% = 1
    Case 2
      attract_mode% = 0
    Case Else
      Error "Invalid value for 'attract_mode%'"
  End Select

  close_controllers()
Loop

End

' Break handler to stop music & fx when Ctrl-C pressed.
Sub on_quit()
  Play Stop
  On Key 3, 0
  Option Break 3
  close_controllers()
  End
End Sub

' Initialises global variables.
Sub init_globals()
  Local i%

  ' Initialise list of controllers.
  If InStr(Mm.Device$, "PicoMite") Then
    Restore controller_data_pm
  Else
    Restore controller_data_cmm2
  EndIf
  Local num_ctrl%
  Read num_ctrl%
  Dim CTRL_NAMES$(num_ctrl% - 1)
  Dim CTRL_SUBS$(num_ctrl% - 1)
  For i% = 0 To num_ctrl% - 1
    Read CTRL_NAMES$(i%), CTRL_SUBS$(i%)
  Next

  ' Initialise high-scores.
  Restore highscore_data
  Local defaults$(Bound(highscr.values$(), 1))
  For i% = 0 To Bound(defaults$(), 1)
    Read defaults$(i%)
  Next
  highscr.load(HIGHSCORE_FILENAME$, defaults$())
End Sub

' Displays the title screen for a specified duration or until the user presses
' START/FIRE/SPACE.
'
' @param duration%  duration in milliseconds; if 0 then indefinite.
' @return           1 if the user pressed button/key,
'                   0 if the duration expired.
Function show_title%(duration%)
  Text X_OFFSET%, Y_OFFSET% - 15, "LAZER CYCLE", "CM", 1, 2, Rgb(White)
  Text X_OFFSET%, Y_OFFSET% + 8, "(c) 2022 Thomas Hugo Williams", "CM", 7, 1, Rgb(Cyan)
  Text X_OFFSET%, Y_OFFSET% + 20, "www.sockpuppetstudios.com", "CM", 7, 1, Rgb(Cyan)
  Local text$ = Choice(Mm.Device$ <> "MMBasic for Windows", "Press START, FIRE or SPACE", "Press SPACE")
  Text X_OFFSET%, Y_OFFSET% + 40, text$, "CM", 1, 1, Rgb(White)
  If IS_CMM2% Then Page Copy 1 To 0, B
  show_title% = wait%(duration%)
End Function

' Displays the highscore table for a specified duration or until the user presses
' START/FIRE/SPACE.
'
' @param duration%  duration in milliseconds; if 0 then indefinite.
' @return           1 if the user pressed button/key,
'                   0 if the duration expired.
Function show_highscore%(duration%)
  Local ctrl$ = highscr.show_table$(5000)
  If ctrl$ <> "" Then
    ui_ctrl$ = ctrl$
    show_highscore% = 1
  EndIf
End Function

Sub clear_display()
   Box 0, 0, Mm.HRes, Mm.VRes, 1, Rgb(Black), Rgb(Black)
   If IS_CMM2% Then Page Copy 1 To 0, B
End Sub

' Waits a specified duration for the user to press START on a (S)NES gamepad
' connected to Port A, or FIRE on an ATARI joystick connected to Port A or
' SPACE on the keyboard.
'
' @param duration%  duration in milliseconds; if 0 then indefinite.
' @return           1 if the user pressed button/key,
'                   0 if the duration expired.
Function wait%(duration%)
  ctrl.init_keys()
  Local ctrl$ = ctrl.poll$(duration%, POLL_THESE$())
  If ctrl$ <> "" Then
    ui_ctrl$ = ctrl$
    wait% = 1
  EndIf
End Function

Sub show_menu()
  Const x% = X_OFFSET% - 100
  Local key%, i%, item% = 0, update% = 1
  Local sounds$(3) = ("MUSIC & FX", "MUSIC ONLY", "FX ONLY   ", "NONE      ")
  Local sound_setting% = 3 - sound.get_state%()

  ' Initialise cycle.ctrl_backup$() on first entry to this subroutine,
  ' subsequent calls use the previously stored state.
  If cycle.ctrl_backup$(0) = "" Then
    cycle.ctrl_backup$(0) = ui_ctrl$
    If cycle.ctrl_backup$(0) = "keys_cursor" Then cycle.ctrl_backup$(0) = "keys_cegg"
    For i% = 1 To MAX_CYCLE_IDX% : cycle.ctrl_backup$(i%) = "ai_control" : Next
  EndIf

  For i% = 0 To MAX_CYCLE_IDX% : cycle.ctrl$(i%) = cycle.ctrl_backup$(i%) : Next

  ' Text X_OFFSET%, Y_OFFSET% + 75, "Music by Scott Joplin", "CM", 7, 1, Rgb(Cyan)
  Text X_OFFSET%, Y_OFFSET% + 90, "Game Version " + VERSION$, "CM", 7, 1, Rgb(Cyan)

  ctrl.init_keys()
  On Error Ignore
  Call ui_ctrl$, ctrl.OPEN
  On Error Abort

  Do

    If update% Then
      Text x%, Y_OFFSET% - 95, "START GAME", , 1, 1, Rgb(White)
      text_for_controller(x%, Y_OFFSET% - 75, 0)
      text_for_controller(x%, Y_OFFSET% - 55, 1)
      text_for_controller(x%, Y_OFFSET% - 35, 2)
      text_for_controller(x%, Y_OFFSET% - 15, 3)
      Text x%, Y_OFFSET% + 5,  "DIFFICULTY: " + Str$(difficulty%), , 1, 1, Rgb(White)
      Text x%, Y_OFFSET% + 25, "SOUND:      " + sounds$(sound_setting%), , 1, 1, Rgb(White)
      Text x%, Y_OFFSET% + 45, "QUIT", , 1, 1, Rgb(White)
      Text x% - 15, Y_OFFSET% - 95 + item% * 20, Chr$(137), , 1, 1, Rgb(Cyan)
      If IS_CMM2% Then Page Copy 1 To 0, B
      Pause 200
      update% = 0
    EndIf

    Call ui_ctrl$, key%
    If key% = 0 Then keys_cursor(key%) ' Always respond to the keyboard.
    Select Case key%
      Case ctrl.START
        Exit Do

      Case ctrl.UP
        If item% > 0 Then
          Text x% - 15, Y_OFFSET% - 95 + item% * 20, Chr$(137), , 1, 1, Rgb(Black)
          Inc item%, -1
          update% = 1
        EndIf

      Case ctrl.DOWN
        If item% < 7 Then
          Text x% - 15, Y_OFFSET% - 95 + item% * 20, Chr$(137), , 1, 1, Rgb(Black)
          Inc item%
          update% = 1
        EndIf

      Case ctrl.LEFT, ctrl.RIGHT, ctrl.A
        Select Case item%
          Case 0
            If key% = ctrl.A Then Exit Do

          Case 1,2,3,4
            update_controller(item% - 1, Choice(key% = ctrl.LEFT, -1, +1))
            update% = 1

          Case 5 ' Difficulty
            Inc difficulty%, Choice(key% = ctrl.LEFT, -1, 1)
            If difficulty% < 1 Then difficulty% = 5
            If difficulty% > 5 Then difficulty% = 1
            update% = 1

          Case 6 ' Sound
            Inc sound_setting%, Choice(key% = ctrl.LEFT, -1, 1)
            If sound_setting% < 0 Then sound_setting% = 3
            If sound_setting% > 3 Then sound_setting% = 0
            If sound_setting% And &b10 Then
              sound.start_music(sound.NO_MUSIC%())
            Else
              sound.start_music(sound.MUSIC%())
            EndIf
            sound.enable_fx(Not (sound_setting% And &b01))
            update% = 1

          Case 7 ' Quit
            If key% = ctrl.A Then on_quit()

        End Select

    End Select

    If update% = 1 Then sound.start_fx(sound.FX_SELECT%(), 1)

  Loop

  For i% = 0 To MAX_CYCLE_IDX% : cycle.ctrl_backup$(i%) = cycle.ctrl$(i%) : Next

  close_controller_no_error(ui_ctrl$)
End Sub

Sub text_for_controller(x%, y%, idx%)
  Local txt$ = "PLAYER " + Str$(idx% + 1) + ":   " + get_controller_name$(idx%)
  Text x%, y%, txt$, , 1, 1, cycle.colour%(idx%)
End Sub

Function get_controller_name$(idx%)
  Local i%
  For i% = 0 To Bound(CTRL_SUBS$(), 1)
    If cycle.ctrl$(idx%) = CTRL_SUBS$(i%) Then
      get_controller_name$ = CTRL_NAMES$(i%)
      Do While Len(get_controller_name$) < 13 : Cat get_controller_name$, " " : Loop
      Exit Function
    Endif
  Next
  Error "Unknown controller: " + cycle.ctrl$(idx%)
End Function

Sub update_controller(idx%, delta%)
  ' Find index of currently selected controller.
  Local i%
  For i% = 0 To Bound(CTRL_SUBS$(), 1)
    If cycle.ctrl$(idx%) = CTRL_SUBS$(i%) Then Exit For
  Next
  If i% = Bound(CTRL_SUBS$(), 1) + 1 Then Error "Unknown controller: " + cycle.ctrl$(idx%)

  Local ok%
  Do
    Inc i%, delta%
    If i% < 0 Then i% = Bound(CTRL_SUBS$(), 1)
    If i% > Bound(CTRL_SUBS$(), 1) Then i% = 0

    ' Check there is no conflict with other player's controller choice.
    If has_controller%(idx%, CTRL_SUBS$(i%)) Then Continue Do
    Select Case CTRL_SUBS$(i%)
      Case "atari_a"   : ok% = Not has_controller%(idx%, "nes_a")
      Case "atari_b"   : ok% = Not has_controller%(idx%, "nes_b")
      Case "nes_a"     : ok% = Not has_controller%(idx%, "atari_a")
      Case "nes_b"     : ok% = Not has_controller%(idx%, "atari_b")
      Case "keys_cegg" : ok% = Not has_controller%(idx%, "keys_azxc")
      Case "keys_azxc" : ok% = Not has_controller%(idx%, "keys_cegg")
      Case Else        : ok% = 1
    End Select
  Loop Until ok%

  cycle.ctrl$(idx%) = CTRL_SUBS$(i%)
End Sub

' Is any player other than idx% using the specified controller ?
Function has_controller%(idx%, ctrl$)
  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    If i% = idx% Then Continue For
    If cycle.ctrl$(i%) = ctrl$ Then has_controller% = 1
  Next
End Function

Sub init_attract_mode()
  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    cycle.ctrl$(i%) = "ai_control"
  Next
  attract_mode% = 1
End Sub

Sub init_game()
  frame_duration% = 3 * (5 + (6 - difficulty%))
  num_players% = 0 ' Incremented later.
  num_humans% = 0
  score% = 0

  ' Initialise the arena.
  Local p_arena% = Peek(VarAddr arena%())
  Memory Set p_arena%, 0, HEIGHT% * WIDTH%
  Memory Set p_arena%, 128, WIDTH%
  Memory Set p_arena% + (HEIGHT% - 1) * WIDTH%, 128, WIDTH%
  Local y%
  For y% = 1 To HEIGHT% - 2
    Poke Byte p_arena% + y% * WIDTH%, 128
    Poke Byte p_arena% + (y% + 1) * WIDTH% - 1, 128
  Next

  cycle.dir%(0) = EAST%
  cycle.dir%(1) = WEST%
  cycle.dir%(2) = SOUTH%
  cycle.dir%(3) = NORTH%

  cycle.pos%(0) = WIDTH * (HEIGHT% \ 2) + 5
  cycle.pos%(1) = WIDTH% * (HEIGHT% \ 2) + WIDTH% - 6
  cycle.pos%(2) = 5.5 * WIDTH%
  cycle.pos%(3) = WIDTH% * (HEIGHT% - 6) + WIDTH% \ 2

  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    cycle.is_ai%(i%) = cycle.ctrl$(i%) = "ai_control"
    cycle.score%(i%) = 0
    If cycle.ctrl$(i%) = "noop_control" Then
      cycle.pos%(i%) = -1
      cycle.nxt%(i%) = -1
      cycle.state%(i%) = STATE_DEAD%
    Else
      Inc num_players%
      If cycle.ctrl$(i%) <> "ai_control" Then Inc num_humans%
      cycle.nxt%(i%) = cycle.pos%(i%) + DIRECTIONS%(cycle.dir%(i%))
      Poke Byte p_arena% + cycle.pos%(i%), (cycle.dir%(i%) << 3) + (i% << 1) + 1
      Poke Byte p_arena% + cycle.nxt%(i%), (cycle.dir%(i%) << 3) + (i% << 1) + 1
      cycle.state%(i%) = STATE_OK%
    EndIf
  Next

  ' Initialise game ports and keyboard routines.
  For i% = 0 To MAX_CYCLE_IDX%
    On Error Ignore
    Call cycle.ctrl$(i%), ctrl.OPEN
    If Mm.ErrNo <> 0 Then cycle.ctrl$(i%) = "noop_control"
    On Error Abort
  Next
  ctrl.init_keys()
End Sub

Sub draw_arena()
  Local a%, i%, j%
  For i% = 0 To Bound(arena%(), 1) - 1
    a% = arena%(i%)
    If a% = 0 Then Continue For
    For j% = 0 To 7
      If Peek(Var a%, j%) <> 128 Then Continue For
      Pixel 2 * (((i% * 8) Mod WIDTH%) + j%), 2 * ((i% * 8) \ WIDTH%), Rgb(Grey)
    Next
  Next
End Sub

' @return  0 - normal game over
'          1 - attract mode game over
'          2 - attract mode interrupted
Function game_loop%()
  Local key%, ctrl$, i%
  game_loop% = attract_mode%
  next_frame% = Timer + frame_duration%

  ' num_players% = 0
  ' cycle.score%(0) = 3175
  ' cycle.score%(1) = 2175
  ' cycle.score%(2) = 1175
  ' cycle.score%(3) = 975
  ' score% = 3175

  Do While num_players% > 0
    Inc score%, 1
    If score% Mod 5 = 0 Then draw_score()

    ' When dying the cycle trail deletes at twice the rate.
    For i% = 0 To MAX_CYCLE_IDX%
      If cycle.state%(i%) = STATE_DYING% Then cycle.dying(i%)
    Next

    ' Draw cycles.
    For i% = 0 To MAX_CYCLE_IDX%
      If Not (cycle.state%(i%) And &b11) Then cycle.draw(i%)
    Next

    If IS_CMM2% Then Page Copy 1 To 0, I

    ' Move cycles.
    For i% = 0 To MAX_CYCLE_IDX%
      If Not (cycle.state%(i%) And &b11) Then cycle.pos%(i%) = cycle.nxt%(i%)
    Next

    ' Determine changes of direction and check for collisions.
    For i% = 0 To MAX_CYCLE_IDX%
      cycle.current% = i%
      Call cycle.ctrl$(i%), key%
      Select Case key%
        Case ctrl.UP:    cycle.dir%(i%) = NORTH%
        Case ctrl.DOWN:  cycle.dir%(i%) = SOUTH%
        Case ctrl.LEFT:  cycle.dir%(i%) = WEST%
        Case ctrl.RIGHT: cycle.dir%(i%) = EAST%
      End Select
      cycle.nxt%(i%) = cycle.pos%(i%) + DIRECTIONS%(cycle.dir%(i%))
      If cycle.state%(i%) <> STATE_DEAD% Then cycle.check_collision(i%)
    Next

    ' Wait for next frame.
    Do While Timer < next_frame% : Loop
    Inc next_frame%, frame_duration%

    If Not attract_mode% Then Continue Do

    ' Check for "attract mode" being interrupted.
    ' TODO: What if controllers have not been configured or all players are AI ?
    For i% = 0 To MAX_CYCLE_IDX%
      If cycle.ctrl_backup$(i%) <> "" Then Call cycle.ctrl_backup$(i%), key%
      If key% = ctrl.A Or key% = ctrl.START Then
        num_players% = 0
        game_loop% = 2
      EndIf
    Next
  Loop

  ' Ensure display updated at end of loop.
  If IS_CMM2% Then Page Copy 1 To 0, B

  ' Wait for current sound effect (if any) to complete.
  sound.wait_for_fx()
End Function

Sub draw_score()
  Local i%, s$ = Str$(score%, 5, 0, "0")
  For i% = 0 To MAX_CYCLE_IDX%
    If cycle.state%(i%) < STATE_DYING% Then
      Text SCORE_X%(i%), SCORE_Y%, s$, , 1, 1, cycle.colour%(i%)
    EndIf
  Next
End Sub

Sub wipe()
  Local y%
  sound.start_fx(sound.FX_WIPE%(), 1)
  For y% = 0 To Mm.VRes \ 2 Step 5
     Box WIDTH% - y% * 1.2, Mm.VRes \ 2 - y%, 2.4 * y%, 2 * y%, 5, Rgb(Cyan), Rgb(Black)
     If IS_CMM2% Then Page Copy 1 To 0, B
     Pause 30
  Next
  clear_display()
End Sub

' Draw cycle if STATE_OK% or STATE_DYING%.
Sub cycle.draw(idx%)
  Local p% = cycle.pos%(idx%), n% = cycle.nxt%(idx%)
  Line 2*(p% Mod WIDTH%), 2*(p%\WIDTH%), 2*(n% Mod WIDTH%), 2*(n%\WIDTH%), 1, cycle.colour%(idx%) * (cycle.state%(idx%) <> STATE_DYING%)
End Sub

Sub cycle.dying(idx%)
  cycle.draw(idx%)
  cycle.pos%(idx%) = cycle.nxt%(idx%) ' Move
  cycle.current% = idx%
  Local key%
  ctrl_die(key%)
  Select Case key%
    Case ctrl.UP:    cycle.dir%(idx%) = NORTH%
    Case ctrl.DOWN:  cycle.dir%(idx%) = SOUTH%
    Case ctrl.LEFT:  cycle.dir%(idx%) = WEST%
    Case ctrl.RIGHT: cycle.dir%(idx%) = EAST%
  End Select
  cycle.nxt%(idx%) = cycle.pos%(idx%) + DIRECTIONS%(cycle.dir%(idx%))
  cycle.check_collision(idx%)
End Sub

Sub show_game_over()
  ' Sort scores and then round down to nearest 5.
  Local dummy%, i%, idx%(MAX_CYCLE_IDX%), j%, k%, winner%
  Sort cycle.score%(), idx%(), 1
  For i% = 0 To MAX_CYCLE_IDX%
    Do While (cycle.score%(i%) Mod 5) <> 0 : Inc cycle.score%(i%), -1 : Loop
  Next
  winner% = idx%(0)

  Local txt$ = "PLAYER " + Str$(winner% + 1) + " WINS"
  Text X_OFFSET%, Y_OFFSET% - 25, txt$, "CM", 1, 2, cycle.colour%(winner%)
  Text X_OFFSET%, Y_OFFSET% + 5, "SCORE: " + Str$(cycle.score%(0)), "CM", 1, 2, cycle.colour%(winner%)
  If IS_CMM2% Then Page Copy 1 To 0, B
  dummy% = wait%(5000)

  wipe()

  ' Insert into high-score table.
  Local new_highscore%, player%
  For i% = 0 To MAX_CYCLE_IDX%
    player% = idx%(i%)
    If cycle.is_ai%(player%) Then Continue For
    For j% = 0 To Bound(highscr.values$())
      If cycle.score%(i%) > Val(Field$(highscr.values$(j%), 2)) Then
        For k% = Bound(highscr.values$(), 1) To j% Step -1
          If k% <> 0 Then highscr.values$(k%) = highscr.values$(k% - 1)
        Next
        highscr.values$(j%) = ", " + Str$(cycle.score%(i%))
        highscr.edit(player% + 1, j%, cycle.colour%(player%), cycle.ctrl_backup$(player%))
        new_highscore% = 1
        Exit For
      EndIf
    Next
  Next
  If new_highscore% Then highscr.save(HIGHSCORE_FILENAME$)
End Sub

Sub ai_control(x%)
  Local idx% = cycle.current%
  Local d% = cycle.dir%(idx%)

  ' Random element.
  Local i% = Int(500 * Rnd)
  If i% < 4 Then d% = NEXT_DIR%(i% + idx%)

  ' Avoid collisions.
  Local nxt%
  For i% = 0 To MAX_CYCLE_IDX%
    nxt% = cycle.pos%(idx%) + DIRECTIONS%(d%)
    If Not Peek(Var arena%(), nxt%)) Then Exit For
    d% = NEXT_DIR%(i% + idx%)
  Next

  x% = COMPASS_TO_CTRL%(d%)
End Sub

Sub ctrl_die(x%)
  x% = COMPASS_TO_CTRL%(((Peek(Var arena%(), cycle.pos%(cycle.current%)) >> 3) + 2) Mod 4)
End Sub

Sub keys_cegg(x%)
  x% =    ctrl.keydown%(97)  * ctrl.UP    ' A
  Inc x%, ctrl.keydown%(122) * ctrl.DOWN  ' Z
  Inc x%, ctrl.keydown%(44)  * ctrl.LEFT  ' comma
  Inc x%, ctrl.keydown%(46)  * ctrl.RIGHT ' full-stop
End Sub

Sub keys_azxc(x%)
  x% =    ctrl.keydown%(97)  * ctrl.UP    ' A
  Inc x%, ctrl.keydown%(122) * ctrl.DOWN  ' Z
  Inc x%, ctrl.keydown%(120) * ctrl.LEFT  ' X
  Inc x%, ctrl.keydown%(99)  * ctrl.RIGHT ' C
End Sub

Sub keys_ikop(x%)
  x% =    ctrl.keydown%(105) * ctrl.UP    ' I
  Inc x%, ctrl.keydown%(107) * ctrl.DOWN  ' K
  Inc x%, ctrl.keydown%(111) * ctrl.LEFT  ' O
  Inc x%, ctrl.keydown%(112) * ctrl.RIGHT ' P
End Function

Sub noop_control(x%)
  x% = 0
End Sub

Sub cycle.check_collision(idx%)
  ' Handle dying.
  If cycle.state%(idx%) = STATE_DYING% Then
    Poke Var arena%(), cycle.pos%(idx%), 0
    Local mask% = (idx% << 1) + 1
    If (Peek(Var arena%(), cycle.nxt%(idx%)) And mask%) <> mask% Then
      cycle.ctrl$(idx%) = "noop_control"
      cycle.state%(idx%) = STATE_DEAD%
      cycle.pos%(idx%) = -1
    EndIf
    Exit Sub
  EndIf

  ' No collision occurred.
  If Not Peek(Var arena%(), cycle.nxt%(idx%)) Then
    Poke Var arena%(), cycle.nxt%(idx%), (cycle.dir%(idx%) << 3) + (idx% << 1) + 1
    cycle.state%(idx%) = STATE_OK%
    Exit Sub
  EndIf

  ' Collision occured - the player has a couple of frames to change direction.
  Inc cycle.state%(idx%)
  If cycle.state%(idx%) < STATE_DYING% Then Exit Sub

  ' Time to die.
  Inc num_players%, -1
  If cycle.ctrl$(idx%) <> "ai_control" Then
    Inc num_humans%, -1
    If num_humans% = 0 Then attract_mode% = 1
  EndIf
  cycle.ctrl$(idx%) = "ctrl_die"
  cycle.nxt%(idx%) = cycle.pos%(idx%)
  cycle.score%(idx%) = score%
  sound.start_fx(sound.FX_DIE%(), 0)
End Sub

Sub close_controllers()
  Local i%
  For i% = 0 To MAX_CYCLE_IDX%
    close_controller_no_error(cycle.ctrl_backup$(i%))
  Next
End Sub

Sub close_controller_no_error(ctrl$)
  On Error Ignore
  Call ctrl$, ctrl.CLOSE
  On Error Abort
End Sub

controller_data_pm:

Data 9
Data "KEYS: AZ,.", "keys_cegg"
Data "KEYS: AZXC", "keys_azxc"
Data "KEYS: IKOP", "keys_ikop"
Data "GAMEPAD A",  "nes_a"
Data "GAMEPAD B",  "nes_b"
Data "JOYSTICK A", "atari_a"
Data "JOYSTICK B", "atari_b"
Data "AI",         "ai_control"
Data "NONE",       "noop_control"

controller_data_cmm2:

Data 9
Data "KEYS: AZ,.",    "keys_cegg"
Data "KEYS: AZXC",    "keys_azxc"
Data "KEYS: IKOP",    "keys_ikop"
Data "JOYSTICK DX",   "atari_dx"
Data "WII CLASSIC 1", "wii_classic_3" ' Port 1 => I2C3
Data "WII CLASSIC 2", "wii_classic_1" ' Port 2 => I2C1
Data "WII CLASSIC 3", "wii_classic_2" ' Port 3 => I2C2
Data "AI",            "ai_control"
Data "NONE",          "noop_control"

highscore_data:

Data "TOM, 2000"
Data "MICKEY, 1500"
Data "MIKE, 1250"
Data "PETER, 1000"
Data "DAVEY, 800"
Data "JOHN, 600"
Data "PAUL, 400"
Data "GEORGE, 200"
Data "RINGO, 100"
Data "MOOSE, 50"
